/* mbed Microcontroller Library
 * Copyright (c) 2017 ARM Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <string.h>
#include "SpecifiedAddressBlockDevice.h"
#include "mbed_critical.h"

using namespace mbed;
#include <inttypes.h>

#define BLOCK_SIZE         (4096)
#define VIRTUAL_OFFSET     (21 * BLOCK_SIZE)

static const uint8_t mbr_tbl[512] = {
 0xEB,0x3C,0x90,0x4D,0x53,0x44,0x4F,0x53,0x35,0x2E,0x30,0x00,0x10,0x04,0x01,0x00
,0x02,0x00,0x02,0x00,0x00,0xF8,0x02,0x00,0x3F,0x00,0xFF,0x00,0x00,0x00,0x00,0x00
,0x00,0x3F,0x00,0x00,0x80,0x00,0x29,0xC6,0x67,0xF7,0x94,0x4E,0x4F,0x20,0x4E,0x41
,0x4D,0x45,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20,0x33,0xC9
,0x8E,0xD1,0xBC,0xF0,0x7B,0x8E,0xD9,0xB8,0x00,0x20,0x8E,0xC0,0xFC,0xBD,0x00,0x7C
,0x38,0x4E,0x24,0x7D,0x24,0x8B,0xC1,0x99,0xE8,0x3C,0x01,0x72,0x1C,0x83,0xEB,0x3A
,0x66,0xA1,0x1C,0x7C,0x26,0x66,0x3B,0x07,0x26,0x8A,0x57,0xFC,0x75,0x06,0x80,0xCA
,0x02,0x88,0x56,0x02,0x80,0xC3,0x10,0x73,0xEB,0x33,0xC9,0x8A,0x46,0x10,0x98,0xF7
,0x66,0x16,0x03,0x46,0x1C,0x13,0x56,0x1E,0x03,0x46,0x0E,0x13,0xD1,0x8B,0x76,0x11
,0x60,0x89,0x46,0xFC,0x89,0x56,0xFE,0xB8,0x20,0x00,0xF7,0xE6,0x8B,0x5E,0x0B,0x03
,0xC3,0x48,0xF7,0xF3,0x01,0x46,0xFC,0x11,0x4E,0xFE,0x61,0xBF,0x00,0x00,0xE8,0xE6
,0x00,0x72,0x39,0x26,0x38,0x2D,0x74,0x17,0x60,0xB1,0x0B,0xBE,0xA1,0x7D,0xF3,0xA6
,0x61,0x74,0x32,0x4E,0x74,0x09,0x83,0xC7,0x20,0x3B,0xFB,0x72,0xE6,0xEB,0xDC,0xA0
,0xFB,0x7D,0xB4,0x7D,0x8B,0xF0,0xAC,0x98,0x40,0x74,0x0C,0x48,0x74,0x13,0xB4,0x0E
,0xBB,0x07,0x00,0xCD,0x10,0xEB,0xEF,0xA0,0xFD,0x7D,0xEB,0xE6,0xA0,0xFC,0x7D,0xEB
,0xE1,0xCD,0x16,0xCD,0x19,0x26,0x8B,0x55,0x1A,0x52,0xB0,0x01,0xBB,0x00,0x00,0xE8
,0x3B,0x00,0x72,0xE8,0x5B,0x8A,0x56,0x24,0xBE,0x0B,0x7C,0x8B,0xFC,0xC7,0x46,0xF0
,0x3D,0x7D,0xC7,0x46,0xF4,0x29,0x7D,0x8C,0xD9,0x89,0x4E,0xF2,0x89,0x4E,0xF6,0xC6
,0x06,0x96,0x7D,0xCB,0xEA,0x03,0x00,0x00,0x20,0x0F,0xB6,0xC8,0x66,0x8B,0x46,0xF8
,0x66,0x03,0x46,0x1C,0x66,0x8B,0xD0,0x66,0xC1,0xEA,0x10,0xEB,0x5E,0x0F,0xB6,0xC8
,0x4A,0x4A,0x8A,0x46,0x0D,0x32,0xE4,0xF7,0xE2,0x03,0x46,0xFC,0x13,0x56,0xFE,0xEB
,0x4A,0x52,0x50,0x06,0x53,0x6A,0x01,0x6A,0x10,0x91,0x8B,0x46,0x18,0x96,0x92,0x33
,0xD2,0xF7,0xF6,0x91,0xF7,0xF6,0x42,0x87,0xCA,0xF7,0x76,0x1A,0x8A,0xF2,0x8A,0xE8
,0xC0,0xCC,0x02,0x0A,0xCC,0xB8,0x01,0x02,0x80,0x7E,0x02,0x0E,0x75,0x04,0xB4,0x42
,0x8B,0xF4,0x8A,0x56,0x24,0xCD,0x13,0x61,0x61,0x72,0x0B,0x40,0x75,0x01,0x42,0x03
,0x5E,0x0B,0x49,0x75,0x06,0xF8,0xC3,0x41,0xBB,0x00,0x00,0x60,0x66,0x6A,0x00,0xEB
,0xB0,0x42,0x4F,0x4F,0x54,0x4D,0x47,0x52,0x20,0x20,0x20,0x20,0x0D,0x0A,0x52,0x65
,0x6D,0x6F,0x76,0x65,0x20,0x64,0x69,0x73,0x6B,0x73,0x20,0x6F,0x72,0x20,0x6F,0x74
,0x68,0x65,0x72,0x20,0x6D,0x65,0x64,0x69,0x61,0x2E,0xFF,0x0D,0x0A,0x44,0x69,0x73
,0x6B,0x20,0x65,0x72,0x72,0x6F,0x72,0xFF,0x0D,0x0A,0x50,0x72,0x65,0x73,0x73,0x20
,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x20,0x74,0x6F,0x20,0x72,0x65,0x73,0x74,0x61
,0x72,0x74,0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0xCB,0xD8,0x55,0xAA
};

static const uint8_t fat_tbl_1_3[] = {
 0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

static const uint8_t fat_tbl_5[] = {
 0x4D,0x42,0x45,0x44,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x08,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0xB4,0x5B,0x4D,0x4E,0x00,0x00,0x00,0x00,0x00,0x00
,0x42,0x20,0x00,0x49,0x00,0x6E,0x00,0x66,0x00,0x6F,0x00,0x0F,0x00,0x72,0x72,0x00
,0x6D,0x00,0x61,0x00,0x74,0x00,0x69,0x00,0x6F,0x00,0x00,0x00,0x6E,0x00,0x00,0x00
,0x01,0x53,0x00,0x79,0x00,0x73,0x00,0x74,0x00,0x65,0x00,0x0F,0x00,0x72,0x6D,0x00
,0x20,0x00,0x56,0x00,0x6F,0x00,0x6C,0x00,0x75,0x00,0x00,0x00,0x6D,0x00,0x65,0x00
,0x53,0x59,0x53,0x54,0x45,0x4D,0x7E,0x31,0x20,0x20,0x20,0x16,0x00,0x40,0xB3,0x5B
,0x4D,0x4E,0x4D,0x4E,0x00,0x00,0xB4,0x5B,0x4D,0x4E,0x02,0x00,0x00,0x00,0x00,0x00
};

static const uint8_t fat_tbl_9[] = {
 0x2E,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x00,0x40,0xB3,0x5B
,0x4D,0x4E,0x4D,0x4E,0x00,0x00,0xB4,0x5B,0x4D,0x4E,0x02,0x00,0x00,0x00,0x00,0x00
,0x2E,0x2E,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x00,0x40,0xB3,0x5B
,0x4D,0x4E,0x4D,0x4E,0x00,0x00,0xB4,0x5B,0x4D,0x4E,0x00,0x00,0x00,0x00,0x00,0x00
,0x42,0x74,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0xCE,0xFF,0xFF
,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF
,0x01,0x57,0x00,0x50,0x00,0x53,0x00,0x65,0x00,0x74,0x00,0x0F,0x00,0xCE,0x74,0x00
,0x69,0x00,0x6E,0x00,0x67,0x00,0x73,0x00,0x2E,0x00,0x00,0x00,0x64,0x00,0x61,0x00
,0x57,0x50,0x53,0x45,0x54,0x54,0x7E,0x31,0x44,0x41,0x54,0x20,0x00,0x47,0xB3,0x5B
,0x4D,0x4E,0x4D,0x4E,0x00,0x00,0xB4,0x5B,0x4D,0x4E,0x03,0x00,0x0C,0x00,0x00,0x00
,0x42,0x47,0x00,0x75,0x00,0x69,0x00,0x64,0x00,0x00,0x00,0x0F,0x00,0xFF,0xFF,0xFF
,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF
,0x01,0x49,0x00,0x6E,0x00,0x64,0x00,0x65,0x00,0x78,0x00,0x0F,0x00,0xFF,0x65,0x00
,0x72,0x00,0x56,0x00,0x6F,0x00,0x6C,0x00,0x75,0x00,0x00,0x00,0x6D,0x00,0x65,0x00
,0x49,0x4E,0x44,0x45,0x58,0x45,0x7E,0x31,0x20,0x20,0x20,0x20,0x00,0x40,0xB4,0x5B
,0x4D,0x4E,0x4D,0x4E,0x00,0x00,0xB5,0x5B,0x4D,0x4E,0x04,0x00,0x4C,0x00,0x00,0x00
};

static const uint8_t fat_tbl_d[] = {
 0x0C,0x00,0x00,0x00,0xA3,0x09,0xB2,0x4B,0x28,0xCD,0x7F,0x66,0x00,0x00,0x00,0x00
};

static const uint8_t fat_tbl_11[] = {
 0x7B,0x00,0x41,0x00,0x42,0x00,0x41,0x00,0x46,0x00,0x42,0x00,0x37,0x00,0x42,0x00
,0x35,0x00,0x2D,0x00,0x34,0x00,0x41,0x00,0x32,0x00,0x38,0x00,0x2D,0x00,0x34,0x00
,0x33,0x00,0x41,0x00,0x42,0x00,0x2D,0x00,0x42,0x00,0x37,0x00,0x33,0x00,0x46,0x00
,0x2D,0x00,0x30,0x00,0x34,0x00,0x36,0x00,0x44,0x00,0x46,0x00,0x39,0x00,0x43,0x00
,0x39,0x00,0x36,0x00,0x33,0x00,0x41,0x00,0x41,0x00,0x7D,0x00,0x00,0x00,0x00,0x00
};

SpecifiedAddressBlockDevice::SpecifiedAddressBlockDevice(uint32_t address, uint32_t size)
    : _flash(), _base(address), _size(size), _is_initialized(false), _init_ref_count(0), _blocks(0), _is_flash_program(false)
{
}

SpecifiedAddressBlockDevice::~SpecifiedAddressBlockDevice()
{
    deinit();
}

int SpecifiedAddressBlockDevice::init()
{
    if (!_is_initialized) {
        _init_ref_count = 0;
    }

    uint32_t val = core_util_atomic_incr_u32(&_init_ref_count, 1);

    if (val != 1) {
        return BD_ERROR_OK;
    }

    int ret = _flash.init();

    if (ret) {
        core_util_atomic_decr_u32(&_init_ref_count, 1);
        return ret;
    }

    if (_size + _base > _flash.get_flash_size() + _flash.get_flash_start()) {
        core_util_atomic_decr_u32(&_init_ref_count, 1);
        return BD_ERROR_DEVICE_ERROR;
    }

    if (_base < _flash.get_flash_start()) {
        core_util_atomic_decr_u32(&_init_ref_count, 1);
        return BD_ERROR_DEVICE_ERROR;
    }

    if (!_base) {
        _base = _flash.get_flash_start();
    }

    if (!_size) {
        _size = _flash.get_flash_size() - (_base - _flash.get_flash_start());
    }

    if (_blocks == 0) {
        _blocks = new uint8_t*[20];
        if (_blocks == 0) {
            return BD_ERROR_DEVICE_ERROR;
        }
    }
    memset(_blocks, 0, sizeof(uint8_t*) * 20);

    _blocks[0x0]  = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0x0] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0x0], 0, BLOCK_SIZE);
    memcpy(_blocks[0x0], mbr_tbl, sizeof(mbr_tbl));

    _blocks[0x1]  = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0x1] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0x1], 0, BLOCK_SIZE);
    memcpy(_blocks[0x1], fat_tbl_1_3, sizeof(fat_tbl_1_3));

    _blocks[0x3]  = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0x3] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0x3], 0, BLOCK_SIZE);
    memcpy(_blocks[0x3], fat_tbl_1_3, sizeof(fat_tbl_1_3));

    _blocks[0x5]  = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0x5] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0x5], 0, BLOCK_SIZE);
    memcpy(_blocks[0x5], fat_tbl_5, sizeof(fat_tbl_5));

    _blocks[0x9]  = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0x9] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0x9], 0, BLOCK_SIZE);
    memcpy(_blocks[0x9], fat_tbl_9, sizeof(fat_tbl_9));

    _blocks[0xd]  = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0xd] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0xd], 0, BLOCK_SIZE);
    memcpy(_blocks[0xd], fat_tbl_d, sizeof(fat_tbl_d));

    _blocks[0x11] = (uint8_t*)malloc(BLOCK_SIZE);
    if (_blocks[0x11] == 0) {
        return BD_ERROR_DEVICE_ERROR;
    }
    memset(_blocks[0x11], 0, BLOCK_SIZE);
    memcpy(_blocks[0x11], fat_tbl_11, sizeof(fat_tbl_11));

    _is_initialized = true;
    return ret;
}

int SpecifiedAddressBlockDevice::deinit()
{
    if (!_is_initialized) {
        _init_ref_count = 0;
        return 0;
    }

    uint32_t val = core_util_atomic_decr_u32(&_init_ref_count, 1);

    if (val) {
        return 0;
    }

    if (_blocks != 0) {
        for (size_t i = 0; i < 20; i++) {
            if (_blocks[i] != 0) {
                free(_blocks[i]);
            }
        }

        delete[] _blocks;
        _blocks = 0;
    }

    _is_initialized = false;

    return _flash.deinit();
}

bd_size_t SpecifiedAddressBlockDevice::get_read_size() const
{
    return BLOCK_SIZE;
}

bd_size_t SpecifiedAddressBlockDevice::get_program_size() const
{
    return BLOCK_SIZE;
}

bd_size_t SpecifiedAddressBlockDevice::get_erase_size() const
{
    return BLOCK_SIZE;
}

int SpecifiedAddressBlockDevice::get_erase_value() const
{
    if (!_is_initialized) {
        return -1;
    }

    uint8_t erase_val = _flash.get_erase_value();

    return erase_val;
}

bd_size_t SpecifiedAddressBlockDevice::size() const
{
    return _size;
}

int SpecifiedAddressBlockDevice::read(void *buffer,
                              bd_addr_t virtual_address,
                              bd_size_t size)
{
    int result = BD_ERROR_DEVICE_ERROR;

    /* Check that the address and size are properly aligned and fit. */
    if (_is_initialized && is_valid_read(virtual_address, size)) {
        if (virtual_address < VIRTUAL_OFFSET) {
            while (size > 0) {
                bd_addr_t hi = virtual_address / BLOCK_SIZE;

                if (_blocks[hi] != 0) {
                    memcpy(buffer, _blocks[hi], BLOCK_SIZE);
                } else {
                    memset(buffer, 0, size);
                }

                buffer = (void *)((uint32_t)buffer + BLOCK_SIZE);
                virtual_address += BLOCK_SIZE;
                size -= BLOCK_SIZE;
            }
            result = BD_ERROR_OK;
        } else {
            /* Convert virtual address to the physical address for the device. */
            bd_addr_t physical_address = _base + virtual_address - VIRTUAL_OFFSET;

            /* Read data using the internal flash driver. */
            result = _flash.read(buffer, physical_address, size);
        }
    }

    return result;
}

int SpecifiedAddressBlockDevice::program(const void *buffer,
                                 bd_addr_t virtual_address,
                                 bd_size_t size)
{
    int result = BD_ERROR_DEVICE_ERROR;

    /* Check that the address and size are properly aligned and fit. */
    if (_is_initialized && is_valid_program(virtual_address, size)) {
        if (virtual_address < VIRTUAL_OFFSET) {
            while (size > 0) {
                bd_addr_t hi = virtual_address / BLOCK_SIZE;

                if (_blocks[hi] == 0) {
                    _blocks[hi] = (uint8_t*)malloc(BLOCK_SIZE);
                }
                if (_blocks[hi] != 0) {
                    memcpy(_blocks[hi], buffer, BLOCK_SIZE);
                }

                buffer = (void *)((uint32_t)buffer + BLOCK_SIZE);
                virtual_address += BLOCK_SIZE;
                size -= BLOCK_SIZE;
            }
            result = BD_ERROR_OK;
        } else {
            /* Convert virtual address to the physical address for the device. */
            bd_addr_t physical_address = _base + virtual_address - VIRTUAL_OFFSET;

            /* Write data using the internal flash driver. */
            result = _flash.program(buffer, physical_address, size);
            if (result == BD_ERROR_OK) {
                _is_flash_program = true;
            }
        }
    }

    return result;
}

int SpecifiedAddressBlockDevice::erase(bd_addr_t virtual_address,
                               bd_size_t size)
{
    int result = BD_ERROR_DEVICE_ERROR;

    /* Check that the address and size are properly aligned and fit. */
    if (_is_initialized && is_valid_erase(virtual_address, size)) {
        if (virtual_address < VIRTUAL_OFFSET) {
            while (size > 0) {
                bd_addr_t hi = virtual_address / BLOCK_SIZE;

                if (_blocks[hi] == 0) {
                    _blocks[hi] = (uint8_t*)malloc(BLOCK_SIZE);
                }
                if (_blocks[hi] != 0) {
                    memset(_blocks[hi], 0xff, BLOCK_SIZE);
                }

                virtual_address += BLOCK_SIZE;
                size -= BLOCK_SIZE;
            }
            result = BD_ERROR_OK;
        } else {
            /* Convert virtual address to the physical address for the device. */
            bd_addr_t physical_address = _base + virtual_address - VIRTUAL_OFFSET;

            /* Erase sector */
            result = _flash.erase(physical_address, size);
        }
    }

    return result;
}

const char *SpecifiedAddressBlockDevice::get_type() const
{
    return "FLASH";
}

bool SpecifiedAddressBlockDevice::is_flash_program()
{
    return _is_flash_program;
}
